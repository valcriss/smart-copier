# Smart Copier â€“ Agent Specification## 1. Objectif du projetSmart Copier est un service **dockerisable** avec **interface web** permettant de copier automatiquement des fichiers dâ€™un rÃ©pertoire source vers un rÃ©pertoire destination **une seule fois dans leur vie**.Un fichier dÃ©jÃ  copiÃ© ne doit **jamais** Ãªtre recopiÃ©, mÃªme si :- il est supprimÃ© de la destination- il est dÃ©placÃ©- le conteneur redÃ©marreLe service doit fournir une **interface web de configuration**, un **suivi en temps rÃ©el** (fichier en cours, progression), et conserver un **historique persistant**.---## 2. Contraintes fonctionnelles clÃ©s (non nÃ©gociables)### 2.1 RÃ¨gle fondamentale> Un fichier est copiÃ© **au maximum une seule fois**, basÃ© sur son contenu (empreinte), et cette dÃ©cision est **persistante**.La destination est **jetable**.  La vÃ©ritÃ© est dans la base de donnÃ©es.---### 2.2 Fichiers en cours dâ€™Ã©critureLe systÃ¨me **ne doit jamais copier un fichier incomplet**.Un fichier nâ€™est considÃ©rÃ© comme prÃªt que si :- sa taille est stable pendant une durÃ©e configurable- son extension nâ€™est pas temporaire (blacklist configurable)- il est accessible en lecture---### 2.3 Progression temps rÃ©elPendant une copie :- le fichier en cours doit Ãªtre visible dans le front- la progression (%) doit Ãªtre prÃ©cise- la vitesse et lâ€™ETA doivent Ãªtre calculables---## 3. Architecture technique imposÃ©e### 3.0 Structure du dÃ©pÃ´t (obligatoire)Le dÃ©pÃ´t doit Ãªtre structurÃ© ainsi :- `/backend` : API, moteur de copie, base SQLite, watchers, SSE, tests backend- `/frontend` : application Vue.js (Vue 3), UI, tests frontendLe build Docker doit produire une image qui embarque le backend et le frontend (frontend compilÃ© puis servi statiquement par le backend), sauf si une architecture multi-images est explicitement documentÃ©e (non requise pour la V1).---## 3. Architecture technique imposÃ©e### 3.1 Stack- **Backend** : Node.js (>= 18)- **Framework HTTP** : Express- **Base de donnÃ©es** : SQLite (fichier unique)- **Watcher filesystem** : chokidar- **UI** : **Vue.js (Vue 3 recommandÃ©)**- **Styles** : **Tailwind CSS exclusivement** (frontend)- **Temps rÃ©el** : Server-Sent Events (SSE)- **Conteneurisation** : DockerLe frontend Vue.js est soit :- servi comme fichiers statiques par le backend Express- soit construit sÃ©parÃ©ment puis copiÃ© dans lâ€™image Docker---### 3.3 Configuration dâ€™environnement (backend)La lecture des variables dâ€™environnement doit Ãªtre **centralisÃ©e** dans une classe unique :- `EnvironmentConfiguration`Cette classe est la **seule** autorisÃ©e Ã  lire `process.env`.Elle doit :- exposer des getters typÃ©s (string/number/boolean)- appliquer des valeurs par dÃ©faut documentÃ©es- valider les valeurs (ex : nombres > 0)- gÃ©rer la **prioritÃ©** des sources de configuration (voir section 10)Aucun autre module du backend ne doit accÃ©der directement Ã  `process.env`.- **Backend** : Node.js (>= 18)- **Framework HTTP** : Express- **Base de donnÃ©es** : SQLite (fichier unique)- **Watcher filesystem** : chokidar- **UI** : **Vue.js (Vue 3 recommandÃ©)**- **Temps rÃ©el** : Server-Sent Events (SSE)- **Conteneurisation** : DockerLe frontend Vue.js est soit :- servi comme fichiers statiques par le backend Express- soit construit sÃ©parÃ©ment puis copiÃ© dans lâ€™image Docker---### 3.2 Volumes DockerLe conteneur ne doit jamais accÃ©der librement au systÃ¨me hÃ´te.Volumes attendus :- `/sources` : source (lecture seule)- `/destinations` : destination (lecture / Ã©criture)- `/data` : Ã©tat persistant (SQLite + config)Les chemins configurables dans lâ€™UI doivent Ãªtre **strictement limitÃ©s** Ã  ces racines.---## 4. Identification des fichiers### 4.1 Empreinte (fingerprint)Chaque fichier doit Ãªtre identifiÃ© par une empreinte stable basÃ©e sur :- taille du fichier- hash du contenu (SHA-256 recommandÃ©)Cette empreinte est la clÃ© primaire logique du systÃ¨me.---### 4.2 Comportement attendu- si une empreinte existe en base avec statut `COPIED` â†’ ignorer dÃ©finitivement- mÃªme si le fichier nâ€™existe plus en destination---## 5. Gestion des fichiers en cours dâ€™Ã©criture### 5.1 DÃ©tection de stabilitÃ©Un fichier est considÃ©rÃ© stable si :- sa taille ne change pas pendant N secondes (configurable)- sa date de modification ne change pas pendant cette pÃ©riodeLes fichiers non stables doivent rester en Ã©tat `PENDING`.---### 5.2 Extensions temporairesUne blacklist dâ€™extensions doit Ãªtre supportÃ©e (ex :`.part`, `.crdownload`, `.tmp`, `.!qB`).Les fichiers correspondants sont ignorÃ©s tant que lâ€™extension persiste.---## 6. Processus de copie### 6.1 Pipeline obligatoire1. DÃ©tection du fichier2. VÃ©rification stabilitÃ©3. Calcul de lâ€™empreinte4. VÃ©rification en base5. Copie vers destination temporaire6. Rename atomique vers destination finale7. Marquage `COPIED` en base---### 6.2 Copie sÃ©curisÃ©e- la copie se fait vers `destination/.tmp/<filename>.partial`- un rename final valide la copie- aucune Ã©criture directe vers le nom final---### 6.3 ConcurrencePour la premiÃ¨re version :- **une seule copie Ã  la fois**- file dâ€™attente interne FIFO---## 7. Base de donnÃ©es (SQLite)### 7.1 Tables minimales#### files- id (PK)- fingerprint (UNIQUE)- filename- source_path- destination_path- size- status (`PENDING`, `COPYING`, `COPIED`, `FAILED`)- first_seen_at- copied_at- error_message (nullable)#### config- key- value---## 8. API Backend### 8.1 Endpoints REST- `GET /api/config`- `PUT /api/config`- `POST /api/start`- `POST /api/stop`- `POST /api/rescan`- `GET /api/status`- `GET /api/history`---### 8.2 SSEEndpoint :- `GET /api/events`Doit Ã©mettre :- Ã©tat global- fichier en cours- progression (%)- dÃ©bit- ETA---## 9. Interface Web (Vue.js)### 9.1 Ã‰cran principal : DashboardLe frontend doit proposer une page **Dashboard** qui prÃ©sente, pour **chaque association** (rÃ©pertoire input, rÃ©pertoire output) :- la liste des fichiers en cours de copie (mise Ã  jour **temps rÃ©el**)- si aucun fichier : afficher le message exact **"aucune copie en cours"**- un bouton **Modifier**- un bouton **Supprimer**Le Dashboard doit proposer un bouton **Ajouter une association** qui ouvre une **boÃ®te de dialogue modale** permettant de crÃ©er une association (input/output) dans les racines autorisÃ©es.Chaque association est affichÃ©e comme un bloc/carte comprenant :- input- output- Ã©tat (idle/copying/error)- progression si copie en coursLe front ne doit jamais permettre de saisir un chemin arbitraire : uniquement une sÃ©lection dans les racines montÃ©es (ex. `/sources`, `/destinations`).---### 9.2 Pages secondaires attendues- Historique des fichiers- Logs / erreurs---### 9.3 Mise Ã  jour temps rÃ©elLe dashboard doit se mettre Ã  jour via **SSE** (Server-Sent Events) en recevant :- la liste des associations- pour chaque association : le fichier en cours et ses mÃ©triques de progression (bytes copiÃ©s / total, %, dÃ©bit, ETA)---### 9.4 Contraintes UI- aucune saisie libre de chemins systÃ¨me- sÃ©lection uniquement dans les racines montÃ©es- rafraÃ®chissement temps rÃ©el via SSE- **Tailwind CSS exclusivement pour le style** : ne pas Ã©crire de CSS custom, sauf si aucune alternative Tailwind nâ€™est possible (dans ce cas, documenter briÃ¨vement pourquoi)### 9.5 Exigences UX / DesignLâ€™interface doit Ãªtre **moderne, claire et lisible** :- hiÃ©rarchie visuelle Ã©vidente (titres, sections, cartes)- design aÃ©rÃ©, sans surcharge visuelle- Ã©tats clairement identifiables (idle, copie en cours, erreur)- feedback immÃ©diat pour les actions utilisateur (ajout, modification, suppression)- composants cohÃ©rents et rÃ©utilisables (cartes, boutons, modales)Lâ€™objectif est une interface "outil pro" : sobre, efficace, comprÃ©hensible sans documentation.---## 10. Configuration### 10.0 Principe gÃ©nÃ©ralToutes les donnÃ©es de configuration doivent Ãªtre **modifiables via variables dâ€™environnement**.La configuration persistÃ©e en SQLite reste la source de vÃ©ritÃ© **par dÃ©faut**, mais toute variable dâ€™environnement correspondante doit pouvoir **surcharger** le comportement au runtime.**PrioritÃ© des sources** (du plus fort au plus faible) :1. Variables dâ€™environnement2. Valeurs stockÃ©es en SQLite3. Valeurs par dÃ©faut codÃ©es dans `EnvironmentConfiguration`---### 10.1 ParamÃ¨tres persistÃ©s (SQLite)Doit Ãªtre persistÃ©e en SQLite et inclure au minimum :- liste des associations (input/output)- extensions ignorÃ©es- intervalle de scan pÃ©riodique- mode dry-run (optionnel)---### 10.2 ParamÃ¨tres par variables dâ€™environnementLa **durÃ©e dâ€™attente sans changement** avant quâ€™un fichier soit considÃ©rÃ© comme stable/terminÃ© (stability window) doit Ãªtre configurable via une variable dâ€™environnement, par exemple :- `FILE_STABILITY_WINDOW_SECONDS` (valeur par dÃ©faut documentÃ©e)Cette valeur est utilisÃ©e par le backend pour dÃ©cider quand un fichier est prÃªt Ã  Ãªtre hashÃ© puis copiÃ©.En plus, les paramÃ¨tres persistÃ©s doivent pouvoir Ãªtre surchargÃ©s par des variables dâ€™environnement (noms Ã  documenter dans le README), par exemple :- roots autorisÃ©es (si exposÃ©es cÃ´tÃ© backend)- blacklist dâ€™extensions temporaires- intervalle de scan pÃ©riodique- activation du dry-runToutes ces lectures doivent passer par `EnvironmentConfiguration`.---## 11. Robustesse & redÃ©marrageAu redÃ©marrage :- les copies en cours passent en `FAILED`- aucun fichier nâ€™est recopiÃ© sâ€™il est dÃ©jÃ  marquÃ© `COPIED`- un rescan permet de reprendre proprement---## 12. Logging- logs structurÃ©s- erreurs visibles dans lâ€™UI- pas de spam par chunk de copie---## 13. QualitÃ©, tests et couverture### 13.1 Exigence de testsLe projet doit inclure une suite de tests automatisÃ©s avec une **couverture de code de 100%** (backend et frontend).- Backend : tests unitaires et/ou dâ€™intÃ©gration (API, logique de stabilitÃ©, logique dâ€™empreinte, logique de copie, gestion DB, SSE).- Frontend : tests unitaires et/ou composants (Dashboard, modale ajout, boutons modifier/supprimer, affichage "aucune copie en cours", gestion SSE).La CI (ou scripts locaux) doit Ã©chouer si la couverture descend sous 100%.---## 14. Ce que lâ€™agent IA doit produireLâ€™agent doit gÃ©nÃ©rer :- lâ€™intÃ©gralitÃ© du backend Node.js- la base SQLite et migrations initiales- le frontend Vue.js complet- le Dockerfile- un docker-compose dâ€™exemple- une documentation README minimaleLâ€™agent **ne doit pas** :- improviser une autre stack- utiliser une base volatile- ignorer la rÃ¨gle â€œcopiÃ© une seule foisâ€---## 14. Philosophie du projetCe projet privilÃ©gie :- la **fiabilitÃ©** sur la vitesse- la **traÃ§abilitÃ©** sur la magie- la **simplicitÃ© opÃ©rable** sur lâ€™over-engineeringSi un comportement est ambigu, lâ€™agent doit choisir lâ€™option la plus sÃ»re.
---

## Addendum
- Background watcher task starts automatically at server launch and runs continuously.
- Dashboard removes Start/Stop/Rescan controls and shows a badge with task status: running or error.
- Allowed roots are /sources and /destinations. UI selection must list only subdirectories of those roots.
- docker-compose.dev.yml is the local dev compose (build from sources).
- docker-compose.yml builds from the GitHub repo (valcriss/smart-copier).
- GitHub Actions runs lint/tests/build and publishes the Docker image to GHCR (ghcr.io/valcriss/smart-copier).
